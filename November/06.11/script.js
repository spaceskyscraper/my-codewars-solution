'use strict';

// 1. Reverse words
/*
"This is an example!" ==> "sihT si na !elpmaxe"
"double  spaces"      ==> "elbuod  secaps"
*/

const reverseWords = str => str.split(' ').map(el => el.split('').reverse().join('')).join(' ')
/*
Ваше решение работает правильно, но оно может быть немного оптимизировано по производительности. В частности, использование оператора spread ([...el]) 
не обязательно, можно обойтись простым методом split('') для строки.

В целом, ваше решение не требует значительных изменений. Однако можно предложить минимизацию кода, например, сразу воспользоваться методом split('') вместо оператора spread для строк:


Да, использование оператора расширения [...] в сравнении с методом split('') для строк действительно может быть немного медленнее, и вот почему:

Разница между [...] и split(''):
[...el]: Это оператор расширения, который создает новый массив из каждого символа строки. Он проходит по строке, извлекая каждый символ, и помещает его в массив. Это работает на уровне 
JavaScript как создание массива через итерацию по строке. Однако в некоторых случаях это может быть чуть медленнее, так как создается массив из каждого символа вручную.

el.split(''): Этот метод вызывает встроенную функцию JavaScript для разбиения строки на массив символов. Это нативная функция, которая обычно оптимизирована для работы с строками и массивами. 
Она непосредственно возвращает массив, не создавая лишних промежуточных объектов.

Тесты производительности:
На практике разница в производительности между этими двумя подходами скорее всего будет минимальной, если строка не очень большая. Однако для очень больших строк и в коде, который часто выполняется 
(например, в циклах), метод split('') может быть чуть быстрее, поскольку это нативный метод, а не операция развертывания.

Резюме:
В большинстве случаев разница в производительности между [...] и split('') не будет значительной.
split('') может быть немного быстрее, так как это оптимизированная встроенная функция JavaScript.
Если задача не критична по времени (например, не нужно обрабатывать миллионы строк или выполнять это много раз в секунду), то разница будет несущественной.
Заключение:
Если вы хотите максимальную производительность для работы со строками, то стоит использовать split(''), 
но для большинства случаев [...] — это вполне удобное и читаемое решение, которое не окажет большого влияния на производительность.
*/

// console.log(reverseWords("This is an example!")); 

// 2. Playling digits

/*
Разделить число на массив цифр: Например, для числа 89 нужно разбить его на массив цифр [8, 9].

Возведение цифр в степени: Каждую цифру из массива нужно возвести в степень, начиная с p и увеличивая степень для каждой последующей цифры. Для числа 89 и начальной степени p = 1 это будет:

8^1 + 9^2
Проверка на равенство: Далее вычисляем сумму этих степеней. Например, для числа 89:

8¹ + 9² = 8 + 81 = 89
Поиск множителя: После вычисления суммы степеней цифр, нужно проверить, можно ли выразить эту сумму как n * k, где n — исходное число. Это можно сделать, разделив сумму на n. 
Если результат деления целое число, то это и будет искомый множитель k. Иначе возвращаем -1.

Пример для числа 695:

Разделяем на цифры: [6, 9, 5]
Возводим в степени: 6² + 9³ + 5⁴ = 36 + 729 + 625 = 1390
Проверяем: 1390 / 695 = 2, то есть k = 2.
Вывод результата: Если деление на n даёт целое число k, то это и есть ответ. В противном случае возвращаем -1.
*/

function digPow(n, p) {
  // ...
}


// 3. Remove the minimum

function removeSmallest(numbers) {
  const smallestValueOfArr = Math.min(...numbers);
  const indexOfSmallestValue = numbers.indexOf(smallestValueOfArr);


  return numbers.filter((_, i) => i !== indexOfSmallestValue);
}

/*
numbers.filter((_, i) => i !== indexOfSmallestValue);

таким синтаксисом мы удаляем только самый первый наименьший элемент
ChatGPT сказал:
ChatGPT
Да, вы правы. В строке:

js
Копировать код
numbers.filter((_, i) => i !== indexOfSmallestValue);
мы удаляем только первый наименьший элемент, потому что:

indexOfSmallestValue — это индекс первого вхождения наименьшего элемента в массив.
В методе filter мы проверяем, что индекс текущего элемента (i) не равен indexOfSmallestValue. Если это так, то элемент сохраняется в новом массиве, иначе — нет.
Таким образом, если наименьший элемент встречается несколько раз, то indexOfSmallestValue будет указывать только на п


*/

// console.log(removeSmallest([2, 2, 1, 2, 1])); 


// 4. Odd or Even?

function oddOrEven(array) {
    return array.reduce((a, c) => a += c, 0) % 2 === 0 ? 'even' : 'odd'
}

// console.log(oddOrEven([0, -1, -5])); 

// 5. Mumbling
/*
accum("abcd") -> "A-Bb-Ccc-Dddd"
accum("RqaEzty") -> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
accum("cwAt") -> "C-Ww-Aaa-Tttt"

Новая строка должна разделяться - и следующая буква всегда должна быть в верхнем регистре

Решение -
1. Создать новый массив
2. Через цикл for - пушить в новый массив элемент, а затем его меньшую копию взависимости от того какой это элемент по списку(если второй - значит будет aaa, третий - bbbb)
3. через map преобразовать первый символ каждого элемента в верхний регистр
4. return этот массив и join('-') чтобы разделить через - элементы
*/


function accum(s) {
    return s.split('').map((char, index) => char.toUpperCase() + char.toLowerCase().repeat(index)).join('-')
}

console.log(accum("abcd"));

/*
Итоги - 
1. split('') немного быстрее [...] spread синтаксиса
2. filter не сортирует результирующий массив(т.е тот который мы получаем на выходе от применения этого метода к другому массиву)
3. .filter((_, i) => i !== arr.indexOf(smallestValue)) - таким синтаксисом мы убираем только первое наименьшее значение из массива
*/