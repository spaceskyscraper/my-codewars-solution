'use strict';

// 1. Fake binary
/*
Задав строку цифр, замените любую цифру ниже 5 на '0', а любую цифру 5 и выше - на '1'. Верните полученную строку.

Решение
1. Заменить всё что меньше 5 на 0
2. Заменить всё что выше 5 на 1
*/

function fakeBinMySolution(x) {
    return x.split('').map((el) => el >= 5 ? '1' : '0').join('')
}

// codewars solution

const fakeBin = x => x.replace(/\d/g, d => d >= 5 ? '1' : 0)

// console.log(fakeBin('0123456')); 

// 2. Sum Mixed Array

function sumMixMySolution(x) {
    return x.map(Number).reduce((a, b) => a += b, 0)
}

const sumMix = x => x.reduce((a, b) => a + +b, 0) 
// Знак + в +n называется унарным оператором плюс. С помощью +n он преобразует n строку, в целое число n.

// console.log(sumMix(["5", "0", 9, 3, 2, 1, "9", 6, 7])); 
/*
Я не думаю, что это лучшая практика, потому что она проходит через один и тот же массив дважды, чтобы превратить значения в числа
.reduce((a, x) => a + +x, 0) лучше, я думаю (ноль - это начальное значение, поэтому код не сломается, если первый элемент массива будет строкой)
*/

// 3. 
/*
Инициализируйте пустой список для результатов.
Переберите каждую строку в a1.
Для каждой строки в a1 проверьте, является ли она подстрокой любой строки в a2.
Если это так, добавьте ее в список результатов.
Уберите дубликаты, преобразовав список в множество, а затем обратно в список (если нужно).
Отсортируйте полученный список в лексикографическом порядке.
Верните отсортированный список.

Решение -
Сортировка в лексикографическом порядке - .sort()
Преобразование в множество - new Set() - Затем можно ... в массив и получим уникализированный массив

*/

function inArray(array1, array2) {
  const outputArr = [];

  for(let i = 0; i < array1.length; i++) {
    for(let j = 0; j < array2.length; j++) {
        if(array2[j].includes(array1[i])) {
            outputArr.push(array1[i])
            break;
        }
    }
  }

  return [...new Set(outputArr)].sort()
}

// console.log(inArray(["arp", "live", "strong"], ["lively", "alive", "harp", "sharp", "armstrong"])); 


// 4. sentence smash

function smash (words) {
   return words.join(' ')
};

// 5. Binary Addition
function addBinary(a, b) {
    return (a + b).toString(2)
}

// console.log(addBinary(1, 1)); 


// Leetcode practice

// 1. Filter Elements from Array
/*
Если задан целочисленный массив arr и функция фильтрации fn, то возвращается отфильтрованный массив filteredArr.
Функция fn принимает один или два аргумента:
arr[i]- число из массива arr
i - индекс arr[i]
filteredArr должен содержать только те элементы из arr, для которых выражение fn(arr[i], i)равно истинностному значению. Истинное значение - это значение, при котором Boolean(value) возвращает true.
Пожалуйста, решите эту задачу без встроенного метода Array.filter.

Задача - 
1. Отсортировать массив по условию без .filter()
2. Вернуть отсортированный массив

Решение
1. Как сортировать массив по условию без .filter?
*/

const filter = function (arr, fn) {
    const outputArr = [];

    for(let i = 0; i < arr.length; i++) {
        if (fn(arr[i], i)) {
          outputArr.push(arr[i]);
        }
    }

    return outputArr;
};

function greaterThan10 (n) {
    return n > 10;
}

function firstIndex(n, i) {
  return i === 0;
}

// console.log(filter([0, 10, 20, 30], greaterThan10)); // рабочее

console.log(filter([0, 10, 20, 30], greaterThan10));

/*
ИТОГИ - 
1. Сортировка в лексикографическом порядке - .sort()
2. получение уникализированного массива - [...new Set(arr)]
3. Циклы «for» - самые быстрые. Любая другая функция все равно делает это внутри.
4. Знак + в +n называется унарным оператором плюс. С помощью +n он преобразует n строку, в целое число n.

5. использовать map для превращение строковых чисел в числа - плохая практика, если необходимо их потом свести к одному значению. Вот решение -
Я не думаю, что это лучшая практика, потому что она проходит через один и тот же массив дважды, чтобы превратить значения в числа
.reduce((a, x) => a + +x, 0) лучше, я думаю (ноль - это начальное значение, поэтому код не сломается, если первый элемент массива будет строкой)

6. Чтобы проверить является ли строка подстрокой используется .includes()
7. чтобы конвертировать число в binary используется .toString(2)
*/

